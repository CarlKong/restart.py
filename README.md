# restart.py
测试环境:
* 操作系统
    * Linux 3.10.0
    * MacOS 10.13.6
* 脚本版本
    * Python 2.7(Linux最原生的Python解释器)

## 一、Use
### 1.*server*
服务入口程序目录，目录名是自定义的。在这个仓库的server中，是一个基于python-WSGI接口的WEB服务器，通过`http://<server-ip>:8000`进行访问，将会简单的返回json脚本`{"msg":"running"}`。

### 2.*sbin*
这个目录是启动脚本目录，用于管理服务的启动、关闭以及重启。目录名可以自定义。
```sh
# 进入脚本目录(非必须，所有的脚本都会重置sbin目录为工作路径)
>> cd <prefix-dir>/sbin

# 启动程序
>> ./start.sh

# 停止程序
>> ./stop.sh

# 杀死程序, 会被重启
>> ./kill.sh

# 安装定时器
>> ./install_timer.py

# 重启程序，安装了定时器后才会定时执行，否则也只有手动输入执行
>> ./restart.sh
```

## 二、Performance
### 1.*Lock Pid*
pid锁是一个`<入口程序路径>.pid`的文件，其中保存了运行进程的pid。该文件的目的是对进程上锁，这个锁并非用于资源共享的锁，而是对进程的正常运行进行确保的锁。当该锁存在时，若进程无端崩溃或是被kill，`restart.py`脚本将会重新拉起进程。pid锁文件其实只在`restart.py`脚本中用到。

### 2.*cfg.py*
cfg.py文件用于指定运行的进程名称，以及进程启动的配置，需要用户根据实际运行情况进行编写。通常只需要修改`process_name`和`process_cmd`这两个变量即可:
```py
# 进程的入口程序，可以时绝对路径，也可以时相对路径。相对路径的根路径一定是sbin文件夹
__fpath__ = "../server/runserver.py"

# 进程启动命令，通常在这里指定进程的启动形式，如是否为守护进程，是否将不显示输出，以及参数的指定
__startup__  = "nohup {__fpath__} > /dev/null 2>&1 &"

# pid搜索方式:
#   lsof_cwd, lsof -p <pid>，通过lsof指令获取入口程序目录(本质上是工作路径)
#   proc_cwd, /proc/<pid>/cwd，通过/proc的软连接获得入口程序目录(本质上是工作路径)
#   proc_exe, /proc/<pid>/<exe>，通过/proc的软连接获得入口程序目录(准确的入口程序目录)
search_dir_type = SearchDirType.lsof_cwd
```
对于获取入口程序目录的模式，更多请看[Attention](#Attention)

### 3.*start.py*
start.py文件对程序进行启动，确保程序正常启动，生成对应的pid锁。脚本的工作有以下几点:
* 检查进程是否存在(程序名所对应的pid是否存在)，存在则刷新pid文件
* 进程不存在，则修改工作路径进行启动，启动后将工作路径恢复
* 检查进程是否正常启动(程序名所对应的pid是否存在)，正常则刷新pid文件

对于一些常见情况的表现：
* 只要进程存在(程序路径可以找到pid)，就会保证最新的pid文件，并且不会额外启动进程。
* 只要进程不存在(程序路径无法找到对应的pid)，
* 遍历pid, 若有pid的工作目录+程序名 == 程序路径，则进程存在，否则进程不存在。

### 4.*stop.py*
stop.py文件确保进程关闭，以及pid锁的删除(避免重新启动)。脚本的工作有以下几点：
* 检查进程是否存在(pid是否存在)，不存在则确保pid锁被删除。
* 进程存在(pid存在)，则发送SIGTERM(15)到对应的进程(pid)
* 检查进程是否存在(pid是否存在)，若进程仍然存在，则停止失败。

### 5.*restart.py*
restart.py文件将会在`pid锁存在`的情况下，查询进程是否存活，若是进程不存在，则尝试重新启动进程。`pid锁不存在`，不进行重启。

## Attention
### 1.*入口程序目录*
入口程序指的是服务的启动文件。通过pid准确获得入口程序路径是非常关键的，因为这个操作会判断进程是否已经启动，并返回对应的pid。`/proc/<pid>/exe`是一个到pid进程路径的软连接，但是这存在两个问题:
* 第三方解释器型服务无法定位。通过Python,Java代码提供服务，都需要经第三方解释器加载代码进行解释，此时`/proc/<pid>/<exe>`定位到的是解释器路径，而非服务的入口路径。
* 对其他Unix系统的兼容问题。某些Unix系统不支持`/proc/`目录，比如MacOS。

无法获得准确的入口路径的定位，只能退而求其次，获取服务的`工作路径`，并认为这是入口程序的路径。获得工作路径的方式有两种：
* `/proc/<pid>/cwd`，对MacOS仍然不友好。
* `lsof`, 可以查询进程的相关信息，包括对文件描述符的占用，以及工作路径。较好的形式，对Linux和MacOS两个平台都能支持的很好。

### 2.*重置工作路径*
在加载服务进程的时候，会将工作路径设置为入口程序路径，这是为了确保`工作路径`即`入口程序路径`，只要服务进程不擅自修改工作路径，`sbin`中脚本就不会丧失对进程的管理能力。若服务进程擅自修改工作路径，导致脚本无法获知进程是否存活，进而造成对进程的新启动，这将会导致多个相同服务的存在(如服务之间完全独立)，或是启动失败(如端口占用)。