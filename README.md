# restart.py
测试环境:
* Linux 3.10.0
* Python 2.7(Linux最原生的Python解释器)

## 一、Use
### 1.*server*
服务入口程序目录，目录名是自定义的。在这个仓库的server中，是一个基于python-WSGI接口的WEB服务器，通过`http://<server-ip>:8000`进行访问，将会简单的返回json脚本`{"msg":"running"}`。

### 2.*sbin*
这个目录是启动脚本目录，用于管理服务的启动、关闭以及重启。目录名可以自定义。
```sh
# 进入脚本目录(非必须，所有的脚本都会重置sbin目录为工作路径)
>> <prefix-dir>/sbin

# 启动程序
>> ./start.sh

# 停止程序
>> ./stop.sh

# 杀死程序, 会被重启
>> ./kill.sh

# 重启程序，后台定时执行
>> ./start.sh
```

## 二、Performance
### 1.*Lock pid*
pid锁是一个`<入口程序路径>.pid`的文件，其中保存了运行进程的pid。该文件的目的是对进程上锁，这个锁并非用于资源共享的锁，而是对进程的正常运行进行确保的锁。当该锁存在时，若进程无端崩溃或是被kill，`restart.py`脚本将会重新拉起进程。pid锁文件其实只在`restart.py`脚本中用到。

### 2.*cfg.py*
cfg.py文件用于指定运行的进程名称，以及进程启动的配置，需要用户根据实际运行情况进行编写。通常只需要修改`process_name`和`process_cmd`这两个变量即可:
```py
# 进程的入口程序，可以时绝对路径，也可以时相对路径。相对路径的根路径一定是sbin文件夹
process_path = "../server/runserver.py"

# 进程启动命令，通常在这里指定进程的启动形式，如是否为守护进程，是否将不显示输出，以及参数的指定
process_cmd  = "nohup {0} > /dev/null 2>&1 &"

# pid搜索方式:
#   0, /proc/<pid>/cwd + name，即工作目录+程序名称的形式，适合于通过解释器启动的服务进程
#   1, /proc/<pid>/<exe>，适合于二进制程序启动的服务器进程
search_pid_type = 0
```

### 3.*start.py*
start.py文件对程序进行启动，确保程序正常启动，生成对应的pid锁。脚本的工作有以下几点:
* 检查进程是否存在(程序名所对应的pid是否存在)，存在则刷新pid文件
* 进程不存在，则修改工作路径进行启动，启动后将工作路径恢复
* 检查进程是否正常启动(程序名所对应的pid是否存在)，正常则刷新pid文件

对于一些常见情况的表现：
* 只要进程存在(程序路径可以找到pid)，就会保证最新的pid文件，并且不会额外启动进程。
* 只要进程不存在(程序路径无法找到对应的pid)，
* 遍历pid, 若有pid的工作目录+程序名 == 程序路径，则进程存在，否则进程不存在。

### 4.*stop.py*
stop.py文件确保进程关闭，以及pid锁的删除(避免重新启动)。脚本的工作有以下几点：
* 检查进程是否存在(pid是否存在)，不存在则确保pid锁被删除。
* 进程存在(pid存在)，则发送SIGTERM(15)到对应的进程(pid)
* 检查进程是否存在(pid是否存在)，若进程仍然存在，则停止失败。

## Attention
### 1.*cwd*
start.py启动一个进程，将会设置进程的工作路径为入口程序的所在路径。工作进程不应该更改这一路径，否则sbin脚本会认为该进程不存在(实际存在)，并重新启动该进程。最终的结果是两个相同的进程会同时工作(在两个进程完全独立时)，或是进程启动失败(例如占用了相应端口等)。
